{
  "contract_name": "cl-vault",
  "contract_version": "0.3.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "admin",
      "config",
      "initial_lower_tick",
      "initial_upper_tick",
      "name",
      "pool_id",
      "range_admin",
      "thesis",
      "vault_token_subdenom"
    ],
    "properties": {
      "admin": {
        "description": "Address that is allowed to update config.",
        "type": "string"
      },
      "config": {
        "description": "Configurable parameters for the contract.",
        "allOf": [
          {
            "$ref": "#/definitions/VaultConfig"
          }
        ]
      },
      "initial_lower_tick": {
        "type": "integer",
        "format": "int64"
      },
      "initial_upper_tick": {
        "type": "integer",
        "format": "int64"
      },
      "name": {
        "description": "the name of the vault",
        "type": "string"
      },
      "pool_id": {
        "description": "The ID of the pool that this vault will autocompound.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "range_admin": {
        "description": "Address that is allowed to update range.",
        "type": "string"
      },
      "thesis": {
        "description": "The general thesis of the vault",
        "type": "string"
      },
      "vault_token_subdenom": {
        "description": "The subdenom that will be used for the native vault token, e.g. the denom of the vault token will be: \"factory/{vault_contract}/{vault_token_subdenom}\".",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "VaultConfig": {
        "type": "object",
        "required": [
          "dex_router",
          "performance_fee",
          "swap_admin",
          "swap_max_slippage",
          "treasury"
        ],
        "properties": {
          "dex_router": {
            "$ref": "#/definitions/Addr"
          },
          "performance_fee": {
            "$ref": "#/definitions/Decimal"
          },
          "swap_admin": {
            "$ref": "#/definitions/Addr"
          },
          "swap_max_slippage": {
            "$ref": "#/definitions/Decimal"
          },
          "treasury": {
            "$ref": "#/definitions/Addr"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "The default ExecuteMsg variants that all vaults must implement. This enum can be extended with additional variants by defining an extension enum and then passing it as the generic argument `T` to this enum.",
    "oneOf": [
      {
        "description": "Called to deposit an any of the assets into the vault. Assets are passed in the funds parameter. This should functions as a deposit function that \"just handles the deposit\", it might swap user funds to the ratio needed. This should support both single sided deposits aswell as unbalanced deposits",
        "type": "object",
        "required": [
          "any_deposit"
        ],
        "properties": {
          "any_deposit": {
            "type": "object",
            "required": [
              "amount",
              "asset",
              "max_slippage"
            ],
            "properties": {
              "amount": {
                "description": "The amount of tokens to deposit.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "asset": {
                "description": "the asset to deposit",
                "type": "string"
              },
              "max_slippage": {
                "description": "The maximum slippage allowed for swap between vault assets for deposit",
                "allOf": [
                  {
                    "$ref": "#/definitions/Decimal"
                  }
                ]
              },
              "recipient": {
                "description": "The optional recipient of the vault token. If not set, the caller address will be used instead.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Called to deposit multiple assets into the vault. The assets should be passed in the funds parameter. The vault should either accept funds in the correct ratio and error on incorrect ratio's, or refund and funds that are not in the correct ratio",
        "type": "object",
        "required": [
          "exact_deposit"
        ],
        "properties": {
          "exact_deposit": {
            "type": "object",
            "properties": {
              "recipient": {
                "description": "The optional recipient of the vault token. If not set, the caller address will be used instead.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Called to redeem vault tokens and receive assets back from the vault. The native vault token must be passed in the funds parameter, unless the lockup extension is called, in which case the vault token has already been passed to ExecuteMsg::Unlock.",
        "type": "object",
        "required": [
          "redeem"
        ],
        "properties": {
          "redeem": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The amount of vault tokens sent to the contract. In the case that the vault token is a Cosmos native denom, we of course have this information in info.funds, but if the vault implements the Cw4626 API, then we need this argument. We figured it's better to have one API for both types of vaults, so we require this argument.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "recipient": {
                "description": "An optional field containing which address should receive the withdrawn base tokens. If not set, the caller address will be used instead.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Called to execute functionality of any enabled extensions.",
        "type": "object",
        "required": [
          "vault_extension"
        ],
        "properties": {
          "vault_extension": {
            "$ref": "#/definitions/ExtensionExecuteMsg"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AdminExtensionExecuteMsg": {
        "description": "Apollo extension messages define functionality that is part of all apollo vaults, but not part of the standard.",
        "oneOf": [
          {
            "description": "Update the vault admin.",
            "type": "object",
            "required": [
              "update_admin"
            ],
            "properties": {
              "update_admin": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "description": "The new admin address.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the range adming,",
            "type": "object",
            "required": [
              "update_range_admin"
            ],
            "properties": {
              "update_range_admin": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "description": "the new range admin",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the configuration of the vault.",
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "required": [
                  "updates"
                ],
                "properties": {
                  "updates": {
                    "description": "The config updates.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/VaultConfig"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_metadata"
            ],
            "properties": {
              "update_metadata": {
                "type": "object",
                "required": [
                  "updates"
                ],
                "properties": {
                  "updates": {
                    "description": "The metadata updates.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Metadata"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the dex router address.",
            "type": "object",
            "required": [
              "update_dex_router"
            ],
            "properties": {
              "update_dex_router": {
                "type": "object",
                "properties": {
                  "address": {
                    "description": "The new dex router address.",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Build tick exponent cache",
            "type": "object",
            "required": [
              "build_tick_cache"
            ],
            "properties": {
              "build_tick_cache": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "AuthzExtension": {
        "description": "Extension messages for Authz. This interface basically reexports certain vault functionality but sets recipient forcibly to None",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "exact_deposit"
            ],
            "properties": {
              "exact_deposit": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "any_deposit"
            ],
            "properties": {
              "any_deposit": {
                "type": "object",
                "required": [
                  "max_slippage"
                ],
                "properties": {
                  "max_slippage": {
                    "$ref": "#/definitions/Decimal"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "redeem"
            ],
            "properties": {
              "redeem": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "ExtensionExecuteMsg": {
        "description": "Extension execute messages for an apollo autocompounding vault",
        "oneOf": [
          {
            "description": "Execute Admin operations.",
            "type": "object",
            "required": [
              "admin"
            ],
            "properties": {
              "admin": {
                "$ref": "#/definitions/AdminExtensionExecuteMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "An interface of certain vault interaction with forced values for authz",
            "type": "object",
            "required": [
              "authz"
            ],
            "properties": {
              "authz": {
                "$ref": "#/definitions/AuthzExtension"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Rebalance our liquidity range based on an off-chain message given to us by RANGE_ADMIN",
            "type": "object",
            "required": [
              "modify_range"
            ],
            "properties": {
              "modify_range": {
                "$ref": "#/definitions/ModifyRangeMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "provides a fungify callback interface for the contract to use",
            "type": "object",
            "required": [
              "merge"
            ],
            "properties": {
              "merge": {
                "$ref": "#/definitions/MergePositionMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "provides an entry point for autocompounding idle funds to current position",
            "type": "object",
            "required": [
              "autocompound"
            ],
            "properties": {
              "autocompound": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Distribute any rewards over all users",
            "type": "object",
            "required": [
              "collect_rewards"
            ],
            "properties": {
              "collect_rewards": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "MigrationStep",
            "type": "object",
            "required": [
              "migration_step"
            ],
            "properties": {
              "migration_step": {
                "type": "object",
                "required": [
                  "amount_of_users"
                ],
                "properties": {
                  "amount_of_users": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "SwapNonVaultFunds",
            "type": "object",
            "required": [
              "swap_non_vault_funds"
            ],
            "properties": {
              "swap_non_vault_funds": {
                "type": "object",
                "required": [
                  "swap_operations"
                ],
                "properties": {
                  "swap_operations": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/SwapOperation"
                    }
                  },
                  "twap_window_seconds": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint64",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MergePositionMsg": {
        "type": "object",
        "required": [
          "position_ids"
        ],
        "properties": {
          "position_ids": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "additionalProperties": false
      },
      "Metadata": {
        "type": "object",
        "required": [
          "name",
          "thesis"
        ],
        "properties": {
          "name": {
            "type": "string"
          },
          "thesis": {
            "description": "the underlying thesis of the vault's positions, eg aggresive",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ModifyRangeMsg": {
        "type": "object",
        "required": [
          "lower_price",
          "max_slippage",
          "ratio_of_swappable_funds_to_use",
          "twap_window_seconds",
          "upper_price"
        ],
        "properties": {
          "claim_after": {
            "description": "claim_after optional field, if we off chain computed that incentives have some forfeit duration. this will be persisted in POSITION state",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "forced_swap_route": {
            "description": "forced swap route to take",
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/definitions/SwapAmountInRoute"
            }
          },
          "lower_price": {
            "description": "The new lower bound of the range, this is converted to an 18 precision digit decimal",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_slippage": {
            "description": "max position slippage",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "ratio_of_swappable_funds_to_use": {
            "description": "desired percent of funds to use during the swap step",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "twap_window_seconds": {
            "description": "twap window to use in seconds",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "upper_price": {
            "description": "The new upper bound of the range, this is converted to an 18 precision digit decimal",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SwapAmountInRoute": {
        "type": "object",
        "required": [
          "pool_id",
          "token_out_denom"
        ],
        "properties": {
          "pool_id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "token_out_denom": {
            "type": "string"
          }
        }
      },
      "SwapOperation": {
        "type": "object",
        "required": [
          "pool_id_base",
          "pool_id_quote",
          "token_in_denom"
        ],
        "properties": {
          "forced_swap_route_base": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/definitions/SwapAmountInRoute"
            }
          },
          "forced_swap_route_quote": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/definitions/SwapAmountInRoute"
            }
          },
          "pool_id_base": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "pool_id_quote": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "token_in_denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "VaultConfig": {
        "type": "object",
        "required": [
          "dex_router",
          "performance_fee",
          "swap_admin",
          "swap_max_slippage",
          "treasury"
        ],
        "properties": {
          "dex_router": {
            "$ref": "#/definitions/Addr"
          },
          "performance_fee": {
            "$ref": "#/definitions/Decimal"
          },
          "swap_admin": {
            "$ref": "#/definitions/Addr"
          },
          "swap_max_slippage": {
            "$ref": "#/definitions/Decimal"
          },
          "treasury": {
            "$ref": "#/definitions/Addr"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "The default QueryMsg variants that all vaults must implement. This enum can be extended with additional variants by defining an extension enum and then passing it as the generic argument `T` to this enum.",
    "oneOf": [
      {
        "description": "Returns `VaultStandardInfoResponse` with information on the version of the vault standard used as well as any enabled extensions.",
        "type": "object",
        "required": [
          "vault_standard_info"
        ],
        "properties": {
          "vault_standard_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns `VaultInfoResponse` representing vault requirements, lockup, & vault token denom.",
        "type": "object",
        "required": [
          "info"
        ],
        "properties": {
          "info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns `Uint128` amount of vault tokens that will be returned for the passed in assets. If the vault cannot accept this set tokens, the query should error. This can be due to wrong ratio's, or missing or superfluous assets\n\nAllows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\n\nMust return as close to and no more than the exact amount of vault tokens that would be minted in a deposit call in the same transaction. I.e. Deposit should return the same or more vault tokens as PreviewDeposit if called in the same transaction.",
        "type": "object",
        "required": [
          "preview_deposit"
        ],
        "properties": {
          "preview_deposit": {
            "type": "object",
            "required": [
              "assets"
            ],
            "properties": {
              "assets": {
                "description": "The of assets to deposit.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Coin"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the ratio in which the underlying assets should be deposited. If no ratio is applicable, should return None. Ratios are expressed as a Vec<Coin>. This should be interpreted as a deposit should be some multiplicative of the returned vec.\n\nA vault does not have to guarantee that this ratio is stable.",
        "type": "string",
        "enum": [
          "deposit_ratio"
        ]
      },
      {
        "description": "Returns `Uint128` amount of base tokens that would be withdrawn in exchange for redeeming `amount` of vault tokens.\n\nAllows an on-chain or off-chain user to simulate the effects of their redeem at the current block, given current on-chain conditions.\n\nMust return as close to and no more than the exact amount of base tokens that would be withdrawn in a redeem call in the same transaction.",
        "type": "object",
        "required": [
          "preview_redeem"
        ],
        "properties": {
          "preview_redeem": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The amount of vault tokens to preview redeeming.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of assets managed by the vault denominated in underlying tokens. Useful for display purposes.",
        "type": "object",
        "required": [
          "total_assets"
        ],
        "properties": {
          "total_assets": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns `Uint128` total amount of vault tokens in circulation.",
        "type": "object",
        "required": [
          "total_vault_token_supply"
        ],
        "properties": {
          "total_vault_token_supply": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The amount of vault tokens that the vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\n\nUseful for display purposes and does not have to confer the exact amount of vault tokens returned by the vault if the passed in assets were deposited. This calculation should not reflect the \"per-user\" price-per-share, and instead should reflect the \"average-user’s\" price-per-share, meaning what the average user should expect to see when exchanging to and from.",
        "type": "object",
        "required": [
          "convert_to_shares"
        ],
        "properties": {
          "convert_to_shares": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The amount of base tokens to convert to vault tokens.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Coin"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of base tokens that the Vault would exchange for the `amount` of vault tokens provided, in an ideal scenario where all the conditions are met.\n\nUseful for display purposes and does not have to confer the exact amount of assets returned by the vault if the passed in vault tokens were redeemed. This calculation should not reflect the \"per-user\" price-per-share, and instead should reflect the \"average-user’s\" price-per-share, meaning what the average user should expect to see when exchanging to and from.",
        "type": "object",
        "required": [
          "convert_to_assets"
        ],
        "properties": {
          "convert_to_assets": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "description": "The amount of vault tokens to convert to base tokens.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Handle queries of any enabled extensions.",
        "type": "object",
        "required": [
          "vault_extension"
        ],
        "properties": {
          "vault_extension": {
            "$ref": "#/definitions/ExtensionQueryMsg"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ClQueryMsg": {
        "description": "Extension query messages for related concentrated liquidity",
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "verify_tick_cache"
            ]
          },
          {
            "description": "Get the underlying pool of the vault",
            "type": "object",
            "required": [
              "pool"
            ],
            "properties": {
              "pool": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "position"
            ],
            "properties": {
              "position": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "range_admin"
            ],
            "properties": {
              "range_admin": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ExtensionQueryMsg": {
        "description": "Extension query messages for an apollo autocompounding vault",
        "oneOf": [
          {
            "description": "Metadata surrounding the vault",
            "type": "object",
            "required": [
              "metadata"
            ],
            "properties": {
              "metadata": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Queries related to the lockup extension.",
            "type": "object",
            "required": [
              "balances"
            ],
            "properties": {
              "balances": {
                "$ref": "#/definitions/UserBalanceQueryMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Queries related to Concentrated Liquidity",
            "type": "object",
            "required": [
              "concentrated_liquidity"
            ],
            "properties": {
              "concentrated_liquidity": {
                "$ref": "#/definitions/ClQueryMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Query the DexRouter address",
            "type": "object",
            "required": [
              "dex_router"
            ],
            "properties": {
              "dex_router": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "UserBalanceQueryMsg": {
        "description": "Extension query messages for user balance related queries",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "user_shares_balance"
            ],
            "properties": {
              "user_shares_balance": {
                "type": "object",
                "required": [
                  "user"
                ],
                "properties": {
                  "user": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "user_assets_balance"
            ],
            "properties": {
              "user_assets_balance": {
                "type": "object",
                "required": [
                  "user"
                ],
                "properties": {
                  "user": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "required": [
      "swap_admin"
    ],
    "properties": {
      "swap_admin": {
        "$ref": "#/definitions/Addr"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      }
    }
  },
  "sudo": null,
  "responses": {
    "convert_to_assets": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "convert_to_shares": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "deposit_ratio": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Coin",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Coin"
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultInfoResponse",
      "description": "Returned by QueryMsg::Info and contains information about this vault",
      "type": "object",
      "required": [
        "tokens",
        "vault_token"
      ],
      "properties": {
        "tokens": {
          "description": "The tokens used by the vault and accepted for deposits, withdrawals. the value is a denom if it is a native token and a contract address if it is a cw20 token. The value expression of internal accounting is left up to the vault.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "vault_token": {
          "description": "Vault token. The denom if it is a native token and the contract address if it is a cw20 token.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "preview_deposit": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "preview_redeem": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "total_assets": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Coin",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Coin"
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_vault_token_supply": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "vault_extension": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Empty",
      "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
      "type": "object"
    },
    "vault_standard_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultStandardInfoResponse",
      "description": "Struct returned from QueryMsg::VaultStandardInfo with information about the used version of the vault standard and any extensions used.\n\nThis struct should be stored as an Item under the `vault_standard_info` key, so that other contracts can do a RawQuery and read it directly from storage instead of needing to do a costly SmartQuery.",
      "type": "object",
      "required": [
        "extensions",
        "version"
      ],
      "properties": {
        "extensions": {
          "description": "A list of vault standard extensions used by the vault. E.g. [\"lockup\", \"keeper\"]",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "version": {
          "description": "The version of the vault standard used. A number, e.g. 1, 2, etc.",
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    }
  }
}

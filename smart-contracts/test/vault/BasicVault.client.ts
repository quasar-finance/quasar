/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  ExecuteMsg,
  Uint128,
  Timestamp,
  Uint64,
  Binary,
  Expiration,
  BondResponse,
  StartUnbondResponse,
  UnbondResponse,
  PrimitiveInitMsg,
  Decimal,
  AssetInfoBaseForAddr,
  Addr,
  InstantiateMsg,
  PrimitiveConfig,
  InstantiateMsg1,
  DistributionSchedule,
  QueryMsg,
  Coin,
  VaultTokenInfoResponse,
  AllowanceResponse,
  BalanceResponse,
  ClaimsResponse,
  Claim,
  DepositRatioResponse,
  GetDebugResponse,
  TvlInfoResponse,
  PrimitiveInfo,
  LpCache,
  InvestmentResponse,
  InvestmentInfo,
  PendingBondsResponse,
  BondingStub,
  PendingUnbondsResponse,
  Unbond,
  UnbondingStub,
  TokenInfoResponse,
} from './BasicVault.types'
export interface BasicVaultReadOnlyInterface {
  contractAddress: string
  claims: ({ address }: { address: string }) => Promise<ClaimsResponse>
  investment: () => Promise<InvestmentResponse>
  depositRatio: ({ funds }: { funds: Coin[] }) => Promise<DepositRatioResponse>
  pendingBonds: ({
    address,
  }: {
    address: string
  }) => Promise<PendingBondsResponse>
  getTvlInfo: () => Promise<TvlInfoResponse>
  pendingUnbonds: ({
    address,
  }: {
    address: string
  }) => Promise<PendingUnbondsResponse>
  getDebug: () => Promise<GetDebugResponse>
  balance: ({ address }: { address: string }) => Promise<BalanceResponse>
  tokenInfo: () => Promise<TokenInfoResponse>
  additionalTokenInfo: () => Promise<TokenInfoResponse>
  allowance: ({
    owner,
    spender,
  }: {
    owner: string
    spender: string
  }) => Promise<AllowanceResponse>
}
export class BasicVaultQueryClient implements BasicVaultReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.claims = this.claims.bind(this)
    this.investment = this.investment.bind(this)
    this.depositRatio = this.depositRatio.bind(this)
    this.pendingBonds = this.pendingBonds.bind(this)
    this.getTvlInfo = this.getTvlInfo.bind(this)
    this.pendingUnbonds = this.pendingUnbonds.bind(this)
    this.getDebug = this.getDebug.bind(this)
    this.balance = this.balance.bind(this)
    this.tokenInfo = this.tokenInfo.bind(this)
    this.additionalTokenInfo = this.additionalTokenInfo.bind(this)
    this.allowance = this.allowance.bind(this)
  }

  claims = async ({
    address,
  }: {
    address: string
  }): Promise<ClaimsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      claims: {
        address,
      },
    })
  }
  investment = async (): Promise<InvestmentResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      investment: {},
    })
  }
  depositRatio = async ({
    funds,
  }: {
    funds: Coin[]
  }): Promise<DepositRatioResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      deposit_ratio: {
        funds,
      },
    })
  }
  pendingBonds = async ({
    address,
  }: {
    address: string
  }): Promise<PendingBondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_bonds: {
        address,
      },
    })
  }
  getTvlInfo = async (): Promise<TvlInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_tvl_info: {},
    })
  }
  pendingUnbonds = async ({
    address,
  }: {
    address: string
  }): Promise<PendingUnbondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_unbonds: {
        address,
      },
    })
  }
  getDebug = async (): Promise<GetDebugResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_debug: {},
    })
  }
  balance = async ({
    address,
  }: {
    address: string
  }): Promise<BalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance: {
        address,
      },
    })
  }
  tokenInfo = async (): Promise<TokenInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_info: {},
    })
  }
  additionalTokenInfo = async (): Promise<TokenInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      additional_token_info: {},
    })
  }
  allowance = async ({
    owner,
    spender,
  }: {
    owner: string
    spender: string
  }): Promise<AllowanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      allowance: {
        owner,
        spender,
      },
    })
  }
}
export interface BasicVaultInterface extends BasicVaultReadOnlyInterface {
  contractAddress: string
  sender: string
  bond: (
    {
      recipient,
    }: {
      recipient?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  unbond: (
    {
      amount,
    }: {
      amount?: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  claim: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  bondResponse: (
    {
      bondId,
      shareAmount,
    }: {
      bondId: string
      shareAmount: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  startUnbondResponse: (
    {
      unbondId,
      unlockTime,
    }: {
      unbondId: string
      unlockTime: Timestamp
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  unbondResponse: (
    {
      unbondId,
    }: {
      unbondId: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  transfer: (
    {
      amount,
      recipient,
    }: {
      amount: Uint128
      recipient: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  burn: (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  send: (
    {
      amount,
      contract,
      msg,
    }: {
      amount: Uint128
      contract: string
      msg: Binary
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  increaseAllowance: (
    {
      amount,
      expires,
      spender,
    }: {
      amount: Uint128
      expires?: Expiration
      spender: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  decreaseAllowance: (
    {
      amount,
      expires,
      spender,
    }: {
      amount: Uint128
      expires?: Expiration
      spender: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  transferFrom: (
    {
      amount,
      owner,
      recipient,
    }: {
      amount: Uint128
      owner: string
      recipient: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  sendFrom: (
    {
      amount,
      contract,
      msg,
      owner,
    }: {
      amount: Uint128
      contract: string
      msg: Binary
      owner: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  burnFrom: (
    {
      amount,
      owner,
    }: {
      amount: Uint128
      owner: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  clearCache: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class BasicVaultClient extends BasicVaultQueryClient
  implements BasicVaultInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string,
  ) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.bond = this.bond.bind(this)
    this.unbond = this.unbond.bind(this)
    this.claim = this.claim.bind(this)
    this.bondResponse = this.bondResponse.bind(this)
    this.startUnbondResponse = this.startUnbondResponse.bind(this)
    this.unbondResponse = this.unbondResponse.bind(this)
    this.transfer = this.transfer.bind(this)
    this.burn = this.burn.bind(this)
    this.send = this.send.bind(this)
    this.increaseAllowance = this.increaseAllowance.bind(this)
    this.decreaseAllowance = this.decreaseAllowance.bind(this)
    this.transferFrom = this.transferFrom.bind(this)
    this.sendFrom = this.sendFrom.bind(this)
    this.burnFrom = this.burnFrom.bind(this)
    this.clearCache = this.clearCache.bind(this)
  }

  bond = async (
    {
      recipient,
    }: {
      recipient?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        bond: {
          recipient,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  unbond = async (
    {
      amount,
    }: {
      amount?: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unbond: {
          amount,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  claim = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim: {},
      },
      fee,
      memo,
      funds,
    )
  }
  bondResponse = async (
    {
      bondId,
      shareAmount,
    }: {
      bondId: string
      shareAmount: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        bond_response: {
          bond_id: bondId,
          share_amount: shareAmount,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  startUnbondResponse = async (
    {
      unbondId,
      unlockTime,
    }: {
      unbondId: string
      unlockTime: Timestamp
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        start_unbond_response: {
          unbond_id: unbondId,
          unlock_time: unlockTime,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  unbondResponse = async (
    {
      unbondId,
    }: {
      unbondId: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unbond_response: {
          unbond_id: unbondId,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  transfer = async (
    {
      amount,
      recipient,
    }: {
      amount: Uint128
      recipient: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        transfer: {
          amount,
          recipient,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  burn = async (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        burn: {
          amount,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  send = async (
    {
      amount,
      contract,
      msg,
    }: {
      amount: Uint128
      contract: string
      msg: Binary
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        send: {
          amount,
          contract,
          msg,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  increaseAllowance = async (
    {
      amount,
      expires,
      spender,
    }: {
      amount: Uint128
      expires?: Expiration
      spender: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        increase_allowance: {
          amount,
          expires,
          spender,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  decreaseAllowance = async (
    {
      amount,
      expires,
      spender,
    }: {
      amount: Uint128
      expires?: Expiration
      spender: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        decrease_allowance: {
          amount,
          expires,
          spender,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  transferFrom = async (
    {
      amount,
      owner,
      recipient,
    }: {
      amount: Uint128
      owner: string
      recipient: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        transfer_from: {
          amount,
          owner,
          recipient,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  sendFrom = async (
    {
      amount,
      contract,
      msg,
      owner,
    }: {
      amount: Uint128
      contract: string
      msg: Binary
      owner: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        send_from: {
          amount,
          contract,
          msg,
          owner,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  burnFrom = async (
    {
      amount,
      owner,
    }: {
      amount: Uint128
      owner: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        burn_from: {
          amount,
          owner,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  clearCache = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        clear_cache: {},
      },
      fee,
      memo,
      funds,
    )
  }
}

/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  ExecuteMsg,
  Uint128,
  Binary,
  Timestamp,
  Uint64,
  UnlockOnly,
  IbcPacketAckMsg,
  IbcAcknowledgement,
  IbcPacket,
  IbcEndpoint,
  IbcTimeout,
  IbcTimeoutBlock,
  InstantiateMsg,
  QueryMsg,
  Addr,
  ChannelType,
  Encoding,
  TxType,
  Version,
  HandshakeState,
  ChannelsResponse,
  ChannelInfo,
  IcaMetadata,
  ConfigResponse,
  Config,
  GetQueuesResponse,
  Bond,
  StartUnbond,
  Unbond,
  IcaAddressResponse,
  IcaBalanceResponse,
  Coin,
  IcaChannelResponse,
  ListBondingClaimsResponse,
  IbcMsgKind,
  RawAmount,
  IcaMessages,
  FundPath,
  ListPendingAcksResponse,
  PendingBond,
  OngoingDeposit,
  PendingSingleUnbond,
  PendingReturningUnbonds,
  ReturningUnbond,
  PendingReturningRecovery,
  ReturningRecovery,
  ListPrimitiveSharesResponse,
  SubMsgKind,
  ContractCallback,
  Callback,
  BankMsg,
  ListRepliesResponse,
  BondResponse,
  StartUnbondResponse,
  UnbondResponse,
  ListUnbondingClaimsResponse,
  IbcLock,
  LockResponse,
  Lock,
  LpSharesResponse,
  LpCache,
  OsmoLockResponse,
  PrimitiveSharesResponse,
  SimulatedJoinResponse,
  TrappedErrorsResponse,
  Trap,
  UnbondingClaimResponse,
} from './LpStrategy.types'
export interface LpStrategyReadOnlyInterface {
  contractAddress: string
  channels: () => Promise<ChannelsResponse>
  config: () => Promise<ConfigResponse>
  icaAddress: () => Promise<IcaAddressResponse>
  lock: () => Promise<LockResponse>
  lpShares: () => Promise<LpSharesResponse>
  primitiveShares: () => Promise<PrimitiveSharesResponse>
  icaBalance: () => Promise<IcaBalanceResponse>
  icaChannel: () => Promise<IcaChannelResponse>
  trappedErrors: () => Promise<TrappedErrorsResponse>
  unbondingClaim: ({
    addr,
    id,
  }: {
    addr: Addr
    id: string
  }) => Promise<UnbondingClaimResponse>
  listUnbondingClaims: () => Promise<ListUnbondingClaimsResponse>
  listBondingClaims: () => Promise<ListBondingClaimsResponse>
  listPrimitiveShares: () => Promise<ListPrimitiveSharesResponse>
  listPendingAcks: () => Promise<ListPendingAcksResponse>
  listReplies: () => Promise<ListRepliesResponse>
  osmoLock: () => Promise<OsmoLockResponse>
  simulatedJoin: () => Promise<SimulatedJoinResponse>
  getQueues: () => Promise<GetQueuesResponse>
}
export class LpStrategyQueryClient implements LpStrategyReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.channels = this.channels.bind(this)
    this.config = this.config.bind(this)
    this.icaAddress = this.icaAddress.bind(this)
    this.lock = this.lock.bind(this)
    this.lpShares = this.lpShares.bind(this)
    this.primitiveShares = this.primitiveShares.bind(this)
    this.icaBalance = this.icaBalance.bind(this)
    this.icaChannel = this.icaChannel.bind(this)
    this.trappedErrors = this.trappedErrors.bind(this)
    this.unbondingClaim = this.unbondingClaim.bind(this)
    this.listUnbondingClaims = this.listUnbondingClaims.bind(this)
    this.listBondingClaims = this.listBondingClaims.bind(this)
    this.listPrimitiveShares = this.listPrimitiveShares.bind(this)
    this.listPendingAcks = this.listPendingAcks.bind(this)
    this.listReplies = this.listReplies.bind(this)
    this.osmoLock = this.osmoLock.bind(this)
    this.simulatedJoin = this.simulatedJoin.bind(this)
    this.getQueues = this.getQueues.bind(this)
  }

  channels = async (): Promise<ChannelsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channels: {},
    })
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  icaAddress = async (): Promise<IcaAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ica_address: {},
    })
  }
  lock = async (): Promise<LockResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      lock: {},
    })
  }
  lpShares = async (): Promise<LpSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      lp_shares: {},
    })
  }
  primitiveShares = async (): Promise<PrimitiveSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      primitive_shares: {},
    })
  }
  icaBalance = async (): Promise<IcaBalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ica_balance: {},
    })
  }
  icaChannel = async (): Promise<IcaChannelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ica_channel: {},
    })
  }
  trappedErrors = async (): Promise<TrappedErrorsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      trapped_errors: {},
    })
  }
  unbondingClaim = async ({
    addr,
    id,
  }: {
    addr: Addr
    id: string
  }): Promise<UnbondingClaimResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      unbonding_claim: {
        addr,
        id,
      },
    })
  }
  listUnbondingClaims = async (): Promise<ListUnbondingClaimsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_unbonding_claims: {},
    })
  }
  listBondingClaims = async (): Promise<ListBondingClaimsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_bonding_claims: {},
    })
  }
  listPrimitiveShares = async (): Promise<ListPrimitiveSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_primitive_shares: {},
    })
  }
  listPendingAcks = async (): Promise<ListPendingAcksResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_pending_acks: {},
    })
  }
  listReplies = async (): Promise<ListRepliesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_replies: {},
    })
  }
  osmoLock = async (): Promise<OsmoLockResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      osmo_lock: {},
    })
  }
  simulatedJoin = async (): Promise<SimulatedJoinResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      simulated_join: {},
    })
  }
  getQueues = async (): Promise<GetQueuesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_queues: {},
    })
  }
}
export interface LpStrategyInterface extends LpStrategyReadOnlyInterface {
  contractAddress: string
  sender: string
  bond: (
    {
      id,
    }: {
      id: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  startUnbond: (
    {
      id,
      shareAmount,
    }: {
      id: string
      shareAmount: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  unbond: (
    {
      id,
    }: {
      id: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  setDepositor: (
    {
      depositor,
    }: {
      depositor: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  acceptReturningFunds: (
    {
      id,
    }: {
      id: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  closeChannel: (
    {
      channelId,
    }: {
      channelId: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  returnTransfer: (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  ack: (
    {
      ack,
    }: {
      ack: IbcPacketAckMsg
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  tryIcq: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  unlock: (
    {
      unlockOnly,
    }: {
      unlockOnly: UnlockOnly
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
  manualTimeout: (
    {
      channel,
      seq,
      shouldUnlock,
    }: {
      channel: string
      seq: number
      shouldUnlock: boolean
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class LpStrategyClient extends LpStrategyQueryClient
  implements LpStrategyInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string,
  ) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.bond = this.bond.bind(this)
    this.startUnbond = this.startUnbond.bind(this)
    this.unbond = this.unbond.bind(this)
    this.setDepositor = this.setDepositor.bind(this)
    this.acceptReturningFunds = this.acceptReturningFunds.bind(this)
    this.closeChannel = this.closeChannel.bind(this)
    this.returnTransfer = this.returnTransfer.bind(this)
    this.ack = this.ack.bind(this)
    this.tryIcq = this.tryIcq.bind(this)
    this.unlock = this.unlock.bind(this)
    this.manualTimeout = this.manualTimeout.bind(this)
  }

  bond = async (
    {
      id,
    }: {
      id: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        bond: {
          id,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  startUnbond = async (
    {
      id,
      shareAmount,
    }: {
      id: string
      shareAmount: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        start_unbond: {
          id,
          share_amount: shareAmount,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  unbond = async (
    {
      id,
    }: {
      id: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unbond: {
          id,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  setDepositor = async (
    {
      depositor,
    }: {
      depositor: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_depositor: {
          depositor,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  acceptReturningFunds = async (
    {
      id,
    }: {
      id: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        accept_returning_funds: {
          id,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  closeChannel = async (
    {
      channelId,
    }: {
      channelId: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        close_channel: {
          channel_id: channelId,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  returnTransfer = async (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        return_transfer: {
          amount,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  ack = async (
    {
      ack,
    }: {
      ack: IbcPacketAckMsg
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        ack: {
          ack,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  tryIcq = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        try_icq: {},
      },
      fee,
      memo,
      funds,
    )
  }
  unlock = async (
    {
      unlockOnly,
    }: {
      unlockOnly: UnlockOnly
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unlock: {
          unlock_only: unlockOnly,
        },
      },
      fee,
      memo,
      funds,
    )
  }
  manualTimeout = async (
    {
      channel,
      seq,
      shouldUnlock,
    }: {
      channel: string
      seq: number
      shouldUnlock: boolean
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        manual_timeout: {
          channel,
          seq,
          should_unlock: shouldUnlock,
        },
      },
      fee,
      memo,
      funds,
    )
  }
}

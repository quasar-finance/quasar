import { Writer, Reader } from "protobufjs/minimal";
import { Duration } from "../../../../google/protobuf/duration";
import { PoolAsset } from "../../../../osmosis/gamm/v1beta1/pool";
import { Coin } from "../../../../cosmos/base/v1beta1/coin";
export declare const protobufPackage = "abag.quasarnode.osmosis.gamm.poolmodels";
/**
 * Parameters for changing the weights in a balancer pool smoothly from
 * a start weight and end weight over a period of time.
 * Currently, the only smooth change supported is linear changing between
 * the two weights, but more types may be added in the future.
 * When these parameters are set, the weight w(t) for pool time `t` is the
 * following:
 *   t <= start_time: w(t) = initial_pool_weights
 *   start_time < t <= start_time + duration:
 *     w(t) = initial_pool_weights + (t - start_time) *
 *       (target_pool_weights - initial_pool_weights) / (duration)
 *   t > start_time + duration: w(t) = target_pool_weights
 */
export interface SmoothWeightChangeParams {
    /**
     * The start time for beginning the weight change.
     * If a parameter change / pool instantiation leaves this blank,
     * it should be generated by the state_machine as the current time.
     */
    startTime: Date | undefined;
    /** Duration for the weights to change over */
    duration: Duration | undefined;
    /**
     * The initial pool weights. These are copied from the pool's settings
     * at the time of weight change instantiation.
     * The amount PoolAsset.token.amount field is ignored if present,
     * future type refactorings should just have a type with the denom & weight
     * here.
     */
    initialPoolWeights: PoolAsset[];
    /**
     * The target pool weights. The pool weights will change linearly with respect
     * to time between start_time, and start_time + duration. The amount
     * PoolAsset.token.amount field is ignored if present, future type
     * refactorings should just have a type with the denom & weight here.
     */
    targetPoolWeights: PoolAsset[];
}
/**
 * BalancerPoolParams defined the parameters that will be managed by the pool
 * governance in the future. This params are not managed by the chain
 * governance. Instead they will be managed by the token holders of the pool.
 * The pool's token holders are specified in future_pool_governor.
 */
export interface BalancerPoolParams {
    swapFee: string;
    exitFee: string;
    smoothWeightChangeParams: SmoothWeightChangeParams | undefined;
}
/**
 * option (gogoproto.goproto_getters) = false;
 * option (gogoproto.goproto_stringer) = false;
 * option (cosmos_proto.implements_interface) = "PoolI";
 */
export interface BalancerPool {
    address: string;
    id: number;
    poolParams: BalancerPoolParams | undefined;
    /**
     * This string specifies who will govern the pool in the future.
     * Valid forms of this are:
     * {token name},{duration}
     * {duration}
     * where {token name} if specified is the token which determines the
     * governor, and if not specified is the LP token for this pool.duration is
     * a time specified as 0w,1w,2w, etc. which specifies how long the token
     * would need to be locked up to count in governance. 0w means no lockup.
     * TODO: Further improve these docs
     */
    futurePoolGovernor: string;
    /** sum of all LP tokens sent out */
    totalShares: Coin | undefined;
    /**
     * These are assumed to be sorted by denomiation.
     * They contain the pool asset and the information about the weight
     */
    poolAssets: PoolAsset[];
    /** sum of all non-normalized pool weights */
    totalWeight: string;
}
export declare const SmoothWeightChangeParams: {
    encode(message: SmoothWeightChangeParams, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): SmoothWeightChangeParams;
    fromJSON(object: any): SmoothWeightChangeParams;
    toJSON(message: SmoothWeightChangeParams): unknown;
    fromPartial(object: DeepPartial<SmoothWeightChangeParams>): SmoothWeightChangeParams;
};
export declare const BalancerPoolParams: {
    encode(message: BalancerPoolParams, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): BalancerPoolParams;
    fromJSON(object: any): BalancerPoolParams;
    toJSON(message: BalancerPoolParams): unknown;
    fromPartial(object: DeepPartial<BalancerPoolParams>): BalancerPoolParams;
};
export declare const BalancerPool: {
    encode(message: BalancerPool, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): BalancerPool;
    fromJSON(object: any): BalancerPool;
    toJSON(message: BalancerPool): unknown;
    fromPartial(object: DeepPartial<BalancerPool>): BalancerPool;
};
declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
